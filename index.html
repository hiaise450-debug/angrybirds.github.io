<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
    <meta name="mobile-web-app-capable" content="yes">
    <meta name="apple-mobile-web-app-capable" content="yes">
    <meta name="apple-mobile-web-app-status-bar-style" content="black-translucent">
    <title>Angry Bird-like Game</title>
    <style>
        * {
            box-sizing: border-box;
            -webkit-tap-highlight-color: transparent;
        }

        @import url('https://fonts.googleapis.com/css2?family=Arial:wght@400;700;900&display=swap');

        body {
            display: flex;
            justify-content: center;
            align-items: center;
            min-height: 100vh;
            margin: 0;
            background: linear-gradient(to bottom, #87CEEB, #ADD8E6);
            font-family: 'Arial', sans-serif;
            overflow: hidden;
            position: relative;
            -webkit-user-select: none;
            -moz-user-select: none;
            user-select: none;
        }

        /* Orientation warning for portrait mode */
        .orientation-warning {
            display: none;
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: #000;
            color: white;
            z-index: 9999;
            flex-direction: column;
            justify-content: center;
            align-items: center;
            text-align: center;
            padding: 20px;
            font-family: 'Arial', sans-serif;
        }

        .orientation-warning h2 {
            margin-bottom: 20px;
            font-size: 2em;
            color: #FFD700;
            text-shadow: 2px 2px 4px rgba(0, 0, 0, 0.7);
        }

        .orientation-warning p {
            font-size: 1.2em;
            margin: 10px 0;
            color: #FFF;
            text-shadow: 1px 1px 2px rgba(0, 0, 0, 0.7);
        }

        .rotate-icon {
            font-size: 4em;
            margin: 20px;
            animation: rotate 2s infinite linear;
            color: #FFD700;
        }

        @keyframes rotate {
            from { transform: rotate(0deg); }
            to { transform: rotate(90deg); }
        }

        canvas {
            border: 5px solid #556B2F;
            border-radius: 15px;
            box-shadow: 0 10px 20px rgba(0, 0, 0, 0.3);
            display: block;
            margin: auto;
            touch-action: none;
            background-color: #ADD8E6;
            z-index: 1;
        }

        .game-container {
            position: relative;
            display: flex;
            flex-direction: column;
            align-items: center;
            padding: 20px;
            background-color: rgba(240, 248, 255, 0.95);
            border-radius: 20px;
            box-shadow: 0 15px 30px rgba(0, 0, 0, 0.4);
            z-index: 2;
            font-family: 'Arial', sans-serif;
        }

        .message-box {
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            background-color: rgba(0, 0, 0, 0.9);
            color: #FFD700;
            padding: 30px 50px;
            border-radius: 15px;
            text-align: center;
            font-size: 2em;
            font-weight: bold;
            font-family: 'Arial', sans-serif;
            z-index: 1000;
            display: none;
            box-shadow: 0 8px 25px rgba(0, 0, 0, 0.8);
            border: 3px solid #FFA500;
            text-shadow: 2px 2px 4px rgba(0, 0, 0, 0.8);
            line-height: 1.4;
            white-space: pre-line;
        }

        .start-screen {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: linear-gradient(to bottom, #4CAF50, #2E8B57);
            display: flex;
            flex-direction: column;
            justify-content: center;
            align-items: center;
            z-index: 2000;
            color: white;
            text-shadow: 2px 2px 4px rgba(0, 0, 0, 0.5);
            font-family: 'Arial', sans-serif;
        }

        .start-screen h1 {
            font-size: 4em;
            margin-bottom: 20px;
            letter-spacing: 3px;
            color: #FFD700;
            text-shadow: 3px 3px 6px rgba(0, 0, 0, 0.7);
            font-weight: 900;
        }

        .start-screen p {
            font-size: 1.5em;
            margin: 10px 0 30px;
            color: #FFF;
            text-shadow: 2px 2px 4px rgba(0, 0, 0, 0.6);
            font-weight: bold;
        }

        .start-screen button {
            padding: 18px 40px;
            font-size: 1.8em;
            font-family: 'Arial', sans-serif;
            background: linear-gradient(145deg, #FFD700, #FFA500);
            border: none;
            border-radius: 12px;
            cursor: pointer;
            box-shadow: 0 6px 12px rgba(0, 0, 0, 0.3);
            transition: all 0.3s ease-in-out;
            color: #333;
            font-weight: bold;
            text-shadow: 1px 1px 2px rgba(0, 0, 0, 0.2);
        }

        .start-screen button:hover {
            background: linear-gradient(145deg, #FFA500, #FFD700);
            transform: translateY(-3px);
            box-shadow: 0 8px 15px rgba(0, 0, 0, 0.4);
        }

        .start-screen button:active {
            transform: translateY(1px);
            box-shadow: 0 2px 5px rgba(0, 0, 0, 0.2);
        }

        .score-display, .level-display {
            background-color: rgba(255, 255, 255, 0.95);
            padding: 12px 20px;
            border-radius: 10px;
            box-shadow: 0 4px 8px rgba(0, 0, 0, 0.3);
            font-size: 1.6em;
            font-weight: bold;
            color: #333;
            font-family: 'Arial', sans-serif;
            border: 2px solid #4CAF50;
            margin: 5px;
            text-shadow: 1px 1px 2px rgba(0, 0, 0, 0.1);
        }

        .buttons-container {
            margin-top: 20px;
            display: flex;
            gap: 15px;
        }

        button {
            padding: 12px 25px;
            font-size: 1.1em;
            font-family: 'Arial', sans-serif;
            font-weight: bold;
            color: white;
            background: linear-gradient(145deg, #4CAF50, #45a049);
            border: none;
            border-radius: 8px;
            cursor: pointer;
            box-shadow: 0 4px 6px rgba(0, 0, 0, 0.2);
            transition: all 0.2s ease-in-out;
            outline: none;
            text-shadow: 1px 1px 2px rgba(0, 0, 0, 0.3);
        }

        button:hover {
            background: linear-gradient(145deg, #45a049, #3e8e41);
            transform: translateY(-2px);
            box-shadow: 0 6px 10px rgba(0, 0, 0, 0.3);
        }

        button:active {
            transform: translateY(1px);
            box-shadow: 0 2px 4px rgba(0, 0, 0, 0.2);
        }

        /* New style for the logo image */
        .game-logo {
            width: 200px;
            height: 200px;
            margin-bottom: 20px;
            border-radius: 20px;
            box-shadow: 0 8px 16px rgba(0, 0, 0, 0.5);
            object-fit: cover;
            border: 4px solid #FFD700;
        }

        /* Mobile-specific styles */
        @media (max-width: 1024px) {
            body {
                min-height: 100vh;
                overflow: hidden;
            }

            .game-container {
                width: 100%;
                height: 100%;
                padding: 10px;
                border-radius: 0;
                background-color: rgba(240, 248, 255, 0.95);
            }

            canvas {
                width: 100%;
                height: auto;
                max-height: 70vh;
                border: 3px solid #556B2F;
            }

            .start-screen h1 {
                font-size: 3em;
            }

            .start-screen p {
                font-size: 1.2em;
                text-align: center;
                padding: 0 20px;
            }

            .start-screen button {
                padding: 15px 30px;
                font-size: 1.5em;
            }

            .score-display, .level-display {
                font-size: 1.2em;
                padding: 8px 15px;
            }

            .message-box {
                font-size: 1.5em;
                padding: 20px 30px;
                max-width: 90%;
            }

            .game-logo {
                width: 150px;
                height: 150px;
            }
        }

        /* For very small screens */
        @media (max-width: 480px) {
            .start-screen h1 {
                font-size: 2.2em;
            }

            .start-screen p {
                font-size: 1em;
            }

            .start-screen button {
                padding: 12px 24px;
                font-size: 1.2em;
            }

            .score-display, .level-display {
                font-size: 1em;
                padding: 6px 12px;
            }

            .buttons-container button {
                padding: 10px 20px;
                font-size: 0.9em;
            }
        }

        /* Force landscape on mobile */
        @media screen and (orientation: portrait) and (max-width: 1024px) {
            .orientation-warning {
                display: flex;
            }
            
            .game-container,
            .start-screen {
                display: none !important;
            }
        }

        @media screen and (orientation: landscape) and (max-height: 600px) {
            .game-container {
                padding: 5px;
            }
            
            canvas {
                max-height: 85vh;
            }
            
            .score-display, .level-display {
                font-size: 1em;
                padding: 5px 10px;
            }
            
            .buttons-container {
                margin-top: 10px;
            }
            
            button {
                padding: 8px 16px;
                font-size: 0.9em;
            }
        }
    </style>
</head>
<body>
    <!-- Orientation warning for portrait mode -->
    <div id="orientationWarning" class="orientation-warning">
        <div class="rotate-icon">â†»</div>
        <h2>Please Rotate Your Device</h2>
        <p>This game requires landscape mode for the best experience.</p>
        <p>Please rotate your device to landscape orientation.</p>
    </div>

    <div id="startScreen" class="start-screen">
        <!-- Added image above the title -->
        <img src="AB_GEN2_CG_2021_Red_14_Determined_NoShadow-800x800.png" alt="Angry Birds Logo" class="game-logo">
        <h1>Angry Birds</h1>
        <p>Developed by <b>Harsh Vardhan Singh</b></p>
        <button id="startButton">Start Game</button>
    </div>

    <div id="gameContainer" class="game-container" style="display: none;">
        <canvas id="gameCanvas"></canvas>
        <div class="score-display" id="scoreDisplay">Score: 0</div>
        <div class="level-display" id="levelDisplay">Level: 1</div>
        <div class="buttons-container">
            <button id="resetButton">Reset Game</button>
        </div>
        <div id="messageBox" class="message-box"></div>
    </div>

    <script>
        // Get the canvas element and its 2D rendering context
        const canvas = document.getElementById('gameCanvas');
        const ctx = canvas.getContext('2d');

        // Set canvas dimensions
        canvas.width = 800;
        canvas.height = 500;

        // Game variables
        const GRAVITY = 0.5;
        const GROUND_HEIGHT = 50;
        const SLINGSHOT_X = 100;
        const SLINGSHOT_Y = canvas.height - GROUND_HEIGHT - 20;
        const MAX_PULL_DISTANCE = 100;
        const OBSTACLE_BOUNCE_FACTOR = 0.5;
        const OBSTACLE_FRICTION = 0.9;
        const OBSTACLE_COLLISION_DAMPING = 0.7;

        let bird;
        let obstacles = [];
        let particles = [];
        let scorePopups = [];
        let isDragging = false;
        let launchVelocityX = 0;
        let launchVelocityY = 0;
        let hasLaunched = false;
        let animationFrameId;
        let score = 0;
        let currentLevel = 1;
        const MAX_LEVELS = 3;
        let birdQueue = [];
        let gameState = 'menu';

        let buildingDestroyedTimer = null;
        const DEBRIS_SETTLE_TIME = 1000;

        // DOM elements
        const messageBox = document.getElementById('messageBox');
        const scoreDisplay = document.getElementById('scoreDisplay');
        const levelDisplay = document.getElementById('levelDisplay');
        const startScreen = document.getElementById('startScreen');
        const gameContainer = document.getElementById('gameContainer');
        const startButton = document.getElementById('startButton');

        // Bird object definition
        function Bird(x, y, radius, color, mass = 1.0, type = 'red') {
            this.x = x;
            this.y = y;
            this.radius = radius;
            this.color = color;
            this.vx = 0;
            this.vy = 0;
            this.onGround = false;
            this.trail = [];
            this.trailLength = 30;
            this.trailInterval = 2;
            this.trailCounter = 0;
            this.mass = mass;
            this.type = type;
            this.abilityUsed = false;
        }

        // Draw method for the bird with more detail
        Bird.prototype.draw = function() {
            ctx.save();

            ctx.shadowColor = 'rgba(0, 0, 0, 0.4)';
            ctx.shadowBlur = 8;
            ctx.shadowOffsetX = 4;
            ctx.shadowOffsetY = 4;

            let currentRadius = this.radius;
            if (!hasLaunched && !isDragging) {
                currentRadius += Math.sin(Date.now() * 0.005) * 1;
            }

            // Draw trail
            for (let i = 0; i < this.trail.length; i++) {
                const p = this.trail[i];
                const alpha = (i / this.trail.length) * 0.7;
                ctx.beginPath();
                ctx.arc(p.x, p.y, currentRadius * (i / this.trail.length * 0.5 + 0.5), 0, Math.PI * 2);
                ctx.fillStyle = `rgba(255, 0, 0, ${alpha})`;
                ctx.fill();
                ctx.closePath();
            }

            // Main body with radial gradient for depth
            const gradient = ctx.createRadialGradient(this.x - currentRadius * 0.3, this.y - currentRadius * 0.3, 0, this.x, this.y, currentRadius);
            if (this.type === 'red') {
                gradient.addColorStop(0, '#FF4500');
                gradient.addColorStop(1, this.color);
            } else if (this.type === 'yellow') {
                gradient.addColorStop(0, '#FFFF00');
                gradient.addColorStop(1, '#DAA520');
            }

            ctx.beginPath();
            ctx.arc(this.x, this.y, currentRadius, 0, Math.PI * 2);
            ctx.fillStyle = gradient;
            ctx.fill();
            ctx.strokeStyle = (this.type === 'red') ? '#8B0000' : '#8B4513';
            ctx.lineWidth = 2;
            ctx.stroke();
            ctx.closePath();

            // White belly
            ctx.beginPath();
            ctx.ellipse(this.x, this.y + currentRadius * 0.4, currentRadius * 0.8, currentRadius * 0.5, 0, 0, Math.PI, true);
            ctx.fillStyle = 'white';
            ctx.fill();
            ctx.closePath();

            // Eyes
            ctx.fillStyle = 'white';
            ctx.beginPath();
            ctx.arc(this.x - currentRadius * 0.3, this.y - currentRadius * 0.3, currentRadius * 0.2, 0, Math.PI * 2);
            ctx.arc(this.x + currentRadius * 0.3, this.y - currentRadius * 0.3, currentRadius * 0.2, 0, Math.PI * 2);
            ctx.fill();
            ctx.closePath();

            // Pupils
            ctx.fillStyle = 'black';
            ctx.beginPath();
            ctx.arc(this.x - currentRadius * 0.3, this.y - currentRadius * 0.3, currentRadius * 0.1, 0, Math.PI * 2);
            ctx.arc(this.x + currentRadius * 0.3, this.y - currentRadius * 0.3, currentRadius * 0.1, 0, Math.PI * 2);
            ctx.fill();
            ctx.closePath();

            // Eyebrows (angry look)
            ctx.strokeStyle = 'black';
            ctx.lineWidth = 3;
            ctx.beginPath();
            ctx.moveTo(this.x - currentRadius * 0.4, this.y - currentRadius * 0.5);
            ctx.lineTo(this.x - currentRadius * 0.1, this.y - currentRadius * 0.3);
            ctx.stroke();

            ctx.beginPath();
            ctx.moveTo(this.x + currentRadius * 0.4, this.y - currentRadius * 0.5);
            ctx.lineTo(this.x + currentRadius * 0.1, this.y - currentRadius * 0.3);
            ctx.stroke();

            // Beak
            ctx.fillStyle = 'orange';
            ctx.beginPath();
            ctx.moveTo(this.x + currentRadius * 0.2, this.y + currentRadius * 0.1);
            ctx.lineTo(this.x + currentRadius * 0.8, this.y);
            ctx.lineTo(this.x + currentRadius * 0.2, this.y + currentRadius * 0.4);
            ctx.fill();
            ctx.closePath();

            // Small tail feather
            ctx.fillStyle = (this.type === 'red') ? '#8B0000' : '#DAA520';
            ctx.beginPath();
            ctx.moveTo(this.x - currentRadius * 0.8, this.y + currentRadius * 0.2);
            ctx.lineTo(this.x - currentRadius * 1.1, this.y + currentRadius * 0.4);
            ctx.lineTo(this.x - currentRadius * 0.8, this.y + currentRadius * 0.6);
            ctx.fill();
            ctx.closePath();

            ctx.restore();
        };

        // Special ability for Yellow Bird
        Bird.prototype.specialAbility = function() {
            if (this.type === 'yellow' && !this.abilityUsed) {
                this.vx *= 2.5;
                this.abilityUsed = true;
                createParticles(this.x, this.y, { r: 255, g: 255, b: 0 });
            }
        };

        // Update method for the bird's physics
        Bird.prototype.update = function() {
            if (this.onGround) {
                if (Math.abs(this.vx) < 0.1 && Math.abs(this.vy) < 0.1) {
                    this.trail = [];
                    return;
                }
            }

            this.vy += GRAVITY;
            this.x += this.vx;
            this.y += this.vy;

            // Collision with ground
            if (this.y + this.radius > canvas.height - GROUND_HEIGHT) {
                this.y = canvas.height - GROUND_HEIGHT - this.radius;
                this.vy *= -0.6;
                this.vx *= 0.9;
                if (Math.abs(this.vy) < 1 && Math.abs(this.vx) < 1) {
                    this.onGround = true;
                }
            } else {
                this.onGround = false;
            }

            // Collision with walls
            if (this.x - this.radius < 0) {
                this.x = this.radius;
                this.vx *= -0.8;
            }
            if (this.x + this.radius > canvas.width) {
                this.x = canvas.width - this.radius;
                this.vx *= -0.8;
            }

            // Update trail
            this.trailCounter++;
            if (this.trailCounter % this.trailInterval === 0) {
                this.trail.push({ x: this.x, y: this.y });
                if (this.trail.length > this.trailLength) {
                    this.trail.shift();
                }
            }
        };

        // Obstacle object definition
        function Obstacle(x, y, width, height, color, scoreValue = 100, mass = 1.0, strength = 100) {
            this.initialX = x;
            this.initialY = y;
            this.x = x;
            this.y = y;
            this.width = width;
            this.height = height;
            this.color = color;
            this.scoreValue = scoreValue;
            this.vx = 0;
            this.vy = 0;
            this.angle = 0;
            this.angularVelocity = 0;
            this.onGround = false;
            this.destroyed = false;
            this.isStable = true;
            this.mass = mass;
            this.strength = strength;
            this.initialStrength = strength;
        }

        // Update method for the obstacle's physics
        Obstacle.prototype.update = function() {
            if (this.destroyed) return;

            if (!this.isStable) {
                this.vy += GRAVITY;
                this.x += this.vx;
                this.y += this.vy;
                this.angle += this.angularVelocity;

                // Collision with ground
                if (this.y + this.height > canvas.height - GROUND_HEIGHT) {
                    this.y = canvas.height - GROUND_HEIGHT - this.height;
                    this.vy *= -OBSTACLE_BOUNCE_FACTOR;
                    this.vx *= OBSTACLE_FRICTION;
                    this.angularVelocity *= OBSTACLE_FRICTION;
                    if (Math.abs(this.vy) < 1 && Math.abs(this.vx) < 1 && Math.abs(this.angularVelocity) < 0.01) {
                        this.onGround = true;
                        this.vx = 0;
                        this.vy = 0;
                        this.angularVelocity = 0;
                    }
                } else {
                    this.onGround = false;
                }

                // Collision with walls
                if (this.x < 0) {
                    this.x = 0;
                    this.vx *= -OBSTACLE_BOUNCE_FACTOR;
                    this.angularVelocity *= -0.5;
                }
                if (this.x + this.width > canvas.width) {
                    this.x = canvas.width - this.width;
                    this.vx *= -OBSTACLE_BOUNCE_FACTOR;
                    this.angularVelocity *= -0.5;
                }
            } else {
                this.vx = 0;
                this.vy = 0;
                this.angularVelocity = 0;
            }

            // Mark for destruction if it falls off the bottom of the screen or strength is zero
            if (this.y > canvas.height + 50 || this.strength <= 0) {
                if (!this.destroyed) {
                    score += this.scoreValue;
                    updateScoreDisplay();
                    createScorePopup(this.x + this.width / 2, this.y + this.height / 2, this.scoreValue);
                }
                this.destroyed = true;
            }
        };

        // Draw method for the obstacle
        Obstacle.prototype.draw = function() {
            if (this.destroyed) return;

            ctx.save();
            ctx.shadowColor = 'rgba(0, 0, 0, 0.4)';
            ctx.shadowBlur = 8;
            ctx.shadowOffsetX = 4;
            ctx.shadowOffsetY = 4;

            ctx.translate(this.x + this.width / 2, this.y + this.height / 2);
            ctx.rotate(this.angle);

            // Draw the block itself
            const blockGradient = ctx.createLinearGradient(-this.width / 2, -this.height / 2, this.width / 2, this.height / 2);
            if (this.color === 'brown') {
                blockGradient.addColorStop(0, '#8B4513');
                blockGradient.addColorStop(0.5, '#A0522D');
                blockGradient.addColorStop(1, '#8B4513');
                ctx.fillStyle = blockGradient;
                ctx.fillRect(-this.width / 2, -this.height / 2, this.width, this.height);
            } else if (this.color === 'lightgray') {
                blockGradient.addColorStop(0, '#B0B0B0');
                blockGradient.addColorStop(0.5, '#D3D3D3');
                blockGradient.addColorStop(1, '#B0B0B0');
                ctx.fillStyle = blockGradient;
                ctx.fillRect(-this.width / 2, -this.height / 2, this.width, this.height);
            } else {
                ctx.fillStyle = this.color;
                ctx.fillRect(-this.width / 2, -this.height / 2, this.width, this.height);
            }
            ctx.strokeStyle = '#333';
            ctx.lineWidth = 2;
            ctx.strokeRect(-this.width / 2, -this.height / 2, this.width, this.height);

            ctx.restore();
        };

        // Particle object definition (for visual effects)
        function Particle(x, y, color, size, vx, vy, life) {
            this.x = x;
            this.y = y;
            this.color = color;
            this.size = size;
            this.vx = vx;
            this.vy = vy;
            this.life = life;
            this.maxLife = life;
        }

        Particle.prototype.update = function() {
            this.x += this.vx;
            this.y += this.vy;
            this.vy += GRAVITY * 0.2;
            this.life--;
        };

        Particle.prototype.draw = function() {
            const alpha = this.life / this.maxLife;
            ctx.fillStyle = `rgba(${this.color.r}, ${this.color.g}, ${this.color.b}, ${alpha})`;
            ctx.beginPath();
            ctx.arc(this.x, this.y, this.size, 0, Math.PI * 2);
            ctx.fill();
            ctx.closePath();
        };

        // ScorePopup object definition - FIXED TEXT VISIBILITY
        function ScorePopup(x, y, value) {
            this.x = x;
            this.y = y;
            this.value = value;
            this.life = 60;
            this.vy = -1.5;
        }

        ScorePopup.prototype.update = function() {
            this.y += this.vy;
            this.life--;
        };

        ScorePopup.prototype.draw = function() {
            const alpha = Math.min(1, this.life / 60);
            ctx.font = `bold 28px Arial`;
            ctx.fillStyle = `rgba(255, 215, 0, ${alpha})`; // Gold color
            ctx.strokeStyle = `rgba(0, 0, 0, ${alpha * 0.7})`;
            ctx.lineWidth = 3;
            ctx.textAlign = 'center';
            ctx.textBaseline = 'middle';
            
            // Draw text with stroke for better visibility
            ctx.strokeText(`+${this.value}`, this.x, this.y);
            ctx.fillText(`+${this.value}`, this.x, this.y);
        };

        // Function to initialize or reset the game
        function initGame() {
            if (animationFrameId) {
                cancelAnimationFrame(animationFrameId);
            }

            currentLevel = 1;
            score = 0;

            updateScoreDisplay();
            updateLevelDisplay();

            resetLevel();
            gameState = 'playing';
            
            // Check orientation first
            handleOrientation();
            
            if (gameContainer.style.display === 'none') {
                gameContainer.style.display = 'flex';
                startScreen.style.display = 'none';
            }

            animationFrameId = requestAnimationFrame(animate);
        }

        // Function to reset the bird and level state for a new launch
        function resetBirdForLaunch() {
            const nextBirdType = birdQueue.shift();
            if (nextBirdType) {
                bird = new Bird(SLINGSHOT_X, SLINGSHOT_Y, 20, (nextBirdType === 'red' ? 'red' : 'yellow'), 1.0, nextBirdType);
                hasLaunched = false;
                isDragging = false;
                launchVelocityX = 0;
                launchVelocityY = 0;
                bird.onGround = false;
            } else {
                checkGameOver();
            }
        }

        // Function to set up the obstacles for the current level
        function resetLevel() {
            obstacles = [];
            particles = [];
            scorePopups = [];

            // Define bird queue for each level
            switch (currentLevel) {
                case 1:
                    birdQueue = ['red', 'red', 'red'];
                    break;
                case 2:
                    birdQueue = ['red', 'yellow', 'red'];
                    break;
                case 3:
                    birdQueue = ['yellow', 'red', 'yellow'];
                    break;
            }

            const blockWidth = 40;
            const blockHeight = 40;
            const baseStrength = 10;

            // Define obstacle configurations for each level
            switch (currentLevel) {
                case 1:
                    obstacles.push(new Obstacle(520, canvas.height - GROUND_HEIGHT - blockHeight, blockWidth, blockHeight, 'brown', 100, 5.0, baseStrength));
                    obstacles.push(new Obstacle(520, canvas.height - GROUND_HEIGHT - blockHeight * 2, blockWidth, blockHeight, 'brown', 100, 5.0, baseStrength));
                    obstacles.push(new Obstacle(520, canvas.height - GROUND_HEIGHT - blockHeight * 3, blockWidth, blockHeight, 'brown', 100, 5.0, baseStrength));
                    break;
                case 2:
                    obstacles.push(new Obstacle(500, canvas.height - GROUND_HEIGHT - blockHeight, blockWidth, blockHeight, 'brown', 100, 5.0, baseStrength));
                    obstacles.push(new Obstacle(540, canvas.height - GROUND_HEIGHT - blockHeight, blockWidth, blockHeight, 'brown', 100, 5.0, baseStrength));
                    obstacles.push(new Obstacle(520, canvas.height - GROUND_HEIGHT - blockHeight * 2, blockWidth, blockHeight, 'lightgray', 150, 10.0, baseStrength * 1.5));
                    break;
                case 3:
                    obstacles.push(new Obstacle(520, canvas.height - GROUND_HEIGHT - blockHeight, blockWidth, blockHeight, 'lightgray', 120, 10.0, baseStrength * 2));
                    obstacles.push(new Obstacle(520, canvas.height - GROUND_HEIGHT - blockHeight * 2, blockWidth, blockHeight, 'lightgray', 120, 10.0, baseStrength * 2));
                    obstacles.push(new Obstacle(520, canvas.height - GROUND_HEIGHT - blockHeight * 3, blockWidth, blockHeight, 'lightgray', 110, 10.0, baseStrength * 2));
                    break;
            }

            resetBirdForLaunch();
            messageBox.style.display = 'none';
        }

        // Function to draw the slingshot
        function drawSlingshot() {
            ctx.strokeStyle = 'saddlebrown';
            ctx.lineWidth = 8;
            ctx.lineCap = 'round';

            // Left post
            ctx.beginPath();
            ctx.moveTo(SLINGSHOT_X - 20, SLINGSHOT_Y + 20);
            ctx.lineTo(SLINGSHOT_X - 20, canvas.height - GROUND_HEIGHT);
            ctx.stroke();

            // Right post
            ctx.beginPath();
            ctx.moveTo(SLINGSHOT_X + 20, SLINGSHOT_Y + 20);
            ctx.lineTo(SLINGSHOT_X + 20, canvas.height - GROUND_HEIGHT);
            ctx.stroke();

            // Rubber band (back part)
            ctx.strokeStyle = 'black';
            ctx.lineWidth = 4;
            ctx.beginPath();
            ctx.moveTo(SLINGSHOT_X - 15, SLINGSHOT_Y - 5);
            ctx.lineTo(bird.x, bird.y);
            ctx.stroke();
        }

        // Function to draw the ground with texture
        function drawGround() {
            ctx.fillStyle = '#556B2F';
            ctx.fillRect(0, canvas.height - GROUND_HEIGHT, canvas.width, GROUND_HEIGHT);

            ctx.strokeStyle = '#333';
            ctx.lineWidth = 3;
            ctx.beginPath();
            ctx.moveTo(0, canvas.height - GROUND_HEIGHT);
            ctx.lineTo(canvas.width, canvas.height - GROUND_HEIGHT);
            ctx.stroke();
        }

        // Function to draw simple clouds
        function drawClouds() {
            ctx.fillStyle = 'white';
            ctx.globalAlpha = 0.8;

            // Cloud 1
            ctx.beginPath();
            ctx.arc(150, 80, 30, 0, Math.PI * 2);
            ctx.arc(180, 70, 40, 0, Math.PI * 2);
            ctx.arc(210, 80, 35, 0, Math.PI * 2);
            ctx.arc(170, 90, 30, 0, Math.PI * 2);
            ctx.fill();

            // Cloud 2
            ctx.beginPath();
            ctx.arc(600, 120, 40, 0, Math.PI * 2);
            ctx.arc(640, 110, 50, 0, Math.PI * 2);
            ctx.arc(680, 120, 45, 0, Math.PI * 2);
            ctx.arc(630, 130, 35, 0, Math.PI * 2);
            ctx.fill();

            ctx.globalAlpha = 1.0;
        }

        // Function to draw hills
        function drawHills() {
            ctx.fillStyle = '#6B8E23';
            ctx.beginPath();
            ctx.moveTo(0, canvas.height - GROUND_HEIGHT);
            ctx.lineTo(canvas.width * 0.2, canvas.height - GROUND_HEIGHT - 50);
            ctx.lineTo(canvas.width * 0.4, canvas.height - GROUND_HEIGHT);
            ctx.lineTo(canvas.width * 0.6, canvas.height - GROUND_HEIGHT - 80);
            ctx.lineTo(canvas.width * 0.8, canvas.height - GROUND_HEIGHT - 30);
            ctx.lineTo(canvas.width, canvas.height - GROUND_HEIGHT);
            ctx.closePath();
            ctx.fill();
        }

        // Function to draw the sun
        function drawSun() {
            ctx.beginPath();
            ctx.arc(canvas.width - 100, 100, 50, 0, Math.PI * 2);
            const sunGradient = ctx.createRadialGradient(canvas.width - 100, 100, 0, canvas.width - 100, 100, 50);
            sunGradient.addColorStop(0, 'yellow');
            sunGradient.addColorStop(1, 'orange');
            ctx.fillStyle = sunGradient;
            ctx.fill();
            ctx.closePath();
        }

        // Function to check collision between bird and obstacle
        function checkCollisionBirdObstacle(bird, obstacle) {
            if (obstacle.destroyed) return false;

            // Simple AABB collision check for bird (circle) and obstacle (rectangle)
            const closestX = Math.max(obstacle.x, Math.min(bird.x, obstacle.x + obstacle.width));
            const closestY = Math.max(obstacle.y, Math.min(bird.y, obstacle.y + obstacle.height));

            const dx = bird.x - closestX;
            const dy = bird.y - closestY;
            const distanceSquared = (dx * dx) + (dy * dy);

            if (distanceSquared < (bird.radius * bird.radius)) {
                // Collision detected
                if (obstacle.isStable) {
                    obstacle.isStable = false;
                }

                const distance = Math.sqrt(distanceSquared);
                const overlap = bird.radius - distance;

                // Normalize collision vector
                const normalX = dx / distance;
                const normalY = dy / distance;

                // Separate objects to prevent sticking
                bird.x += normalX * overlap / 2;
                bird.y += normalY * overlap / 2;
                obstacle.x -= normalX * overlap / 2;
                obstacle.y -= normalY * overlap / 2;

                // Calculate relative velocity
                const relativeVx = bird.vx - obstacle.vx;
                const relativeVy = bird.vy - obstacle.vy;

                // Calculate velocity along the normal
                const velAlongNormal = relativeVx * normalX + relativeVy * normalY;

                // Do not resolve if velocities are separating
                if (velAlongNormal > 0) return false;

                // Calculate impulse (simplified for elasticity)
                const elasticity = 0.6;
                let impulse = -(1 + elasticity) * velAlongNormal;
                impulse /= (1 / bird.mass + 1 / obstacle.mass);

                // Apply impulse
                const impulseX = impulse * normalX;
                const impulseY = impulse * normalY;

                bird.vx += impulseX / bird.mass;
                bird.vy += impulseY / bird.mass;
                obstacle.vx -= impulseX / obstacle.mass;
                obstacle.vy -= impulseY / obstacle.mass;

                // Apply rotational force based on impact point (simplified)
                const impactPointX = bird.x - (obstacle.x + obstacle.width / 2);
                const impactPointY = bird.y - (obstacle.y + obstacle.height / 2);
                obstacle.angularVelocity += (impulseX * impactPointY - impulseY * impactPointX) * 0.0001 / obstacle.mass;

                // Reduce obstacle strength based on impact force
                const impactForce = Math.sqrt(impulseX * impulseX + impulseY * impulseY);
                obstacle.strength -= impactForce * 1.0;

                createParticles(bird.x, bird.y, obstacle.color);

                return true;
            }
            return false;
        }

        // Function to check collision between two obstacles
        function checkCollisionObstacleObstacle(obj1, obj2) {
            if (obj1.destroyed || obj2.destroyed) return false;

            if (obj1.isStable && obj2.isStable) {
                return false;
            }

            // Simple AABB overlap check
            if (obj1.x < obj2.x + obj2.width &&
                obj1.x + obj1.width > obj2.x &&
                obj1.y < obj2.y + obj2.height &&
                obj1.y + obj1.height > obj2.y) {

                if (obj1.isStable) obj1.isStable = false;
                if (obj2.isStable) obj2.isStable = false;

                // Calculate overlap and separate
                const dx = (obj1.x + obj1.width / 2) - (obj2.x + obj2.width / 2);
                const dy = (obj1.y + obj1.height / 2) - (obj2.y + obj2.height / 2);

                const overlapX = (obj1.width / 2 + obj2.width / 2) - Math.abs(dx);
                const overlapY = (obj1.height / 2 + obj2.height / 2) - Math.abs(dy);

                if (overlapX < overlapY) {
                    const sign = Math.sign(dx);
                    obj1.x += overlapX / 2 * sign;
                    obj2.x -= overlapX / 2 * sign;
                } else {
                    const sign = Math.sign(dy);
                    obj1.y += overlapY / 2 * sign;
                    obj2.y -= overlapY / 2 * sign;
                }

                // Apply impulse
                const elasticity = 0.5;
                const relativeVx = obj1.vx - obj2.vx;
                const relativeVy = obj1.vy - obj2.vy;

                // Calculate normal vector
                let normalX, normalY;
                if (overlapX < overlapY) {
                    normalX = Math.sign(dx);
                    normalY = 0;
                } else {
                    normalX = 0;
                    normalY = Math.sign(dy);
                }

                const velAlongNormal = relativeVx * normalX + relativeVy * normalY;

                if (velAlongNormal > 0) return false;

                let impulse = -(1 + elasticity) * velAlongNormal;
                impulse /= (1 / obj1.mass + 1 / obj2.mass);

                const impulseX = impulse * normalX;
                const impulseY = impulse * normalY;

                obj1.vx += impulseX / obj1.mass;
                obj1.vy += impulseY / obj1.mass;
                obj2.vx -= impulseX / obj2.mass;
                obj2.vy -= impulseY / obj2.mass;

                // Apply rotational force
                obj1.angularVelocity += (impulseX * (obj1.y - obj2.y) - impulseY * (obj1.x - obj2.x)) * 0.0001 / obj1.mass;
                obj2.angularVelocity += (impulseY * (obj2.x - obj1.x) - impulseX * (obj2.y - obj1.y)) * 0.0001 / obj2.mass;

                // Reduce strength if impact is significant
                const impactForce = Math.sqrt(impulseX * impulseX + impulseY * impulseY);
                obj1.strength -= impactForce * 0.2;
                obj2.strength -= impactForce * 0.2;

                obj1.onGround = false;
                obj2.onGround = false;

                return true;
            }
            return false;
        }

        // Function to create particles at a given position and color
        function createParticles(x, y, color) {
            let r, g, b;
            if (typeof color === 'string') {
                if (color === 'brown') { r = 139; g = 69; b = 19; }
                else if (color === 'lightgray') { r = 211; g = 211; b = 211; }
                else { r = 255; g = 0; b = 0; }
            } else {
                r = color.r; g = color.g; b = color.b;
            }

            for (let i = 0; i < 15; i++) {
                const size = Math.random() * 4 + 1;
                const angle = Math.random() * Math.PI * 2;
                const speed = Math.random() * 7 + 2;
                const vx = Math.cos(angle) * speed;
                const vy = Math.sin(angle) * speed;
                const life = Math.random() * 40 + 30;
                particles.push(new Particle(x, y, { r, g, b }, size, vx, vy, life));
            }
        }

        // Function to create a score popup
        function createScorePopup(x, y, value) {
            scorePopups.push(new ScorePopup(x, y, value));
        }

        // Function to display messages
        function showMessage(msg, duration = 2000) {
            messageBox.textContent = msg;
            messageBox.style.display = 'block';
            if (duration > 0) {
                setTimeout(() => {
                    messageBox.style.display = 'none';
                }, duration);
            }
        }

        // Function to update the score display
        function updateScoreDisplay() {
            scoreDisplay.textContent = `Score: ${score}`;
        }

        // Function to update the level display
        function updateLevelDisplay() {
            levelDisplay.textContent = `Level: ${currentLevel}`;
        }

        // Function to calculate trajectory points for preview
        function getTrajectoryPoints(startX, startY, initialVx, initialVy, numPoints = 60, timeStep = 0.5) {
            const points = [];
            let currentX = startX;
            let currentY = startY;
            let currentVx = initialVx;
            let currentVy = initialVy;

            for (let i = 0; i < numPoints; i++) {
                currentVy += GRAVITY * timeStep;
                currentX += currentVx * timeStep;
                currentY += currentVy * timeStep;
                points.push({ x: currentX, y: currentY });

                // Stop if it goes off screen or hits ground
                if (currentY > canvas.height - GROUND_HEIGHT || currentX < 0 || currentX > canvas.width) {
                    break;
                }
            }
            return points;
        }

        // Game loop
        function animate() {
            ctx.clearRect(0, 0, canvas.width, canvas.height);

            // Draw sky background first
            const skyGradient = ctx.createLinearGradient(0, 0, 0, canvas.height - GROUND_HEIGHT);
            skyGradient.addColorStop(0, '#87CEEB');
            skyGradient.addColorStop(1, '#ADD8E6');
            ctx.fillStyle = skyGradient;
            ctx.fillRect(0, 0, canvas.width, canvas.height - GROUND_HEIGHT);

            drawSun();
            drawClouds();
            drawHills();
            drawGround();
            drawSlingshot();

            // Only update bird physics if in playing state
            if (gameState === 'playing') {
                if (hasLaunched) {
                    bird.update();
                } else if (isDragging) {
                    const trajectoryPoints = getTrajectoryPoints(bird.x, bird.y, launchVelocityX, launchVelocityY);
                    ctx.beginPath();
                    ctx.strokeStyle = 'rgba(0, 0, 0, 0.5)';
                    ctx.lineWidth = 2;
                    ctx.setLineDash([5, 5]);
                    if (trajectoryPoints.length > 0) {
                        ctx.moveTo(trajectoryPoints[0].x, trajectoryPoints[0].y);
                        for (let i = 1; i < trajectoryPoints.length; i++) {
                            ctx.lineTo(trajectoryPoints[i].x, trajectoryPoints[i].y);
                        }
                    }
                    ctx.stroke();
                    ctx.setLineDash([]);
                }
            }
            bird.draw();

            ctx.strokeStyle = 'black';
            ctx.lineWidth = 4;
            ctx.beginPath();
            ctx.moveTo(SLINGSHOT_X + 15, SLINGSHOT_Y - 5);
            ctx.lineTo(bird.x, bird.y);
            ctx.stroke();

            let activeObstacles = [];
            let blocksRemaining = 0;

            for (let i = 0; i < obstacles.length; i++) {
                const obstacle = obstacles[i];
                if (!obstacle.destroyed) {
                    obstacle.update();
                    if (hasLaunched) {
                        checkCollisionBirdObstacle(bird, obstacle);
                    }
                    if (!obstacle.destroyed) {
                        activeObstacles.push(obstacle);
                        blocksRemaining++;
                    }
                }
            }
            obstacles = activeObstacles;

            // Only check obstacle-obstacle collision if there's more than one obstacle
            if (obstacles.length > 1) {
                for (let i = 0; i < obstacles.length; i++) {
                    for (let j = i + 1; j < obstacles.length; j++) {
                        checkCollisionObstacleObstacle(obstacles[i], obstacles[j]);
                    }
                }
            }

            obstacles.forEach(obstacle => obstacle.draw());

            let remainingParticles = [];
            for (let i = 0; i < particles.length; i++) {
                const particle = particles[i];
                particle.update();
                if (particle.life > 0) {
                    particle.draw();
                    remainingParticles.push(particle);
                }
            }
            particles = remainingParticles;

            let remainingScorePopups = [];
            for (let i = 0; i < scorePopups.length; i++) {
                const popup = scorePopups[i];
                popup.update();
                if (popup.life > 0) {
                    popup.draw();
                    remainingScorePopups.push(popup);
                }
            }
            scorePopups = remainingScorePopups;

            const birdSettled = bird.onGround && Math.abs(bird.vx) < 1 && Math.abs(bird.vy) < 1;
            const birdOffScreen = bird.x < -bird.radius || bird.x > canvas.width + bird.radius || bird.y > canvas.height + bird.radius;

            // Level Win Condition: All blocks destroyed
            if (blocksRemaining === 0 && hasLaunched) {
                if (gameState === 'playing') {
                    gameState = 'level_complete';
                    showMessage(`Level ${currentLevel} Complete!\nPreparing next level...`, DEBRIS_SETTLE_TIME + 2000);

                    // Allow debris to settle for DEBRIS_SETTLE_TIME, then advance
                    setTimeout(() => {
                        let currentBlocksRemainingAfterSettle = 0;
                        obstacles.forEach(o => { if (!o.destroyed) currentBlocksRemainingAfterSettle++; });

                        if (currentBlocksRemainingAfterSettle === 0) {
                            currentLevel++;
                            if (currentLevel <= MAX_LEVELS) {
                                resetLevel();
                                gameState = 'playing';
                                updateLevelDisplay();
                            } else {
                                showMessage(`ðŸŽ‰ Winner! You completed all levels! ðŸŽ‰\nFinal Score: ${score}`, 5000);
                                gameState = 'game_over';
                            }
                        } else {
                            gameState = 'playing';
                        }
                    }, DEBRIS_SETTLE_TIME);
                }
            } else if (gameState === 'level_complete' && blocksRemaining > 0) {
                gameState = 'playing';
            }

            // Bird used/Level Loss Condition
            if (hasLaunched && (birdSettled || birdOffScreen)) {
                if (blocksRemaining > 0) {
                    if (birdQueue.length > 0) {
                        resetBirdForLaunch();
                    } else {
                        checkGameOver();
                    }
                }
            }

            animationFrameId = requestAnimationFrame(animate);
        }

        function checkGameOver() {
            let blocksRemaining = 0;
            obstacles.forEach(o => { if (!o.destroyed) blocksRemaining++; });

            if (blocksRemaining > 0) {
                showMessage(`Game Over! Out of birds.\nScore: ${score}`, 4000);
                gameState = 'game_over';
            } else {
                showMessage(`ðŸŽ‰ Winner! You completed all levels! ðŸŽ‰\nFinal Score: ${score}`, 4000);
                gameState = 'game_over';
            }
        }

        // Event listeners for mouse/touch interaction
        canvas.addEventListener('mousedown', handleStart);
        canvas.addEventListener('mousemove', handleMove);
        canvas.addEventListener('mouseup', handleEnd);
        canvas.addEventListener('mouseleave', handleEnd);

        canvas.addEventListener('touchstart', handleStart);
        canvas.addEventListener('touchmove', handleMove);
        canvas.addEventListener('touchend', handleEnd);
        canvas.addEventListener('touchcancel', handleEnd);

        // Event listener for special ability activation
        canvas.addEventListener('click', handleAbilityClick);
        canvas.addEventListener('touchend', handleAbilityClick);

        function handleAbilityClick(event) {
            if (hasLaunched && bird && !bird.abilityUsed) {
                const pos = getEventPos(event);
                const dist = Math.sqrt(Math.pow(pos.x - bird.x, 2) + Math.pow(pos.y - bird.y, 2));
                if (dist < bird.radius * 1.5) {
                    bird.specialAbility();
                }
            }
        }

        function getEventPos(event) {
            const rect = canvas.getBoundingClientRect();
            let clientX, clientY;

            if (event.touches) {
                clientX = event.touches[0].clientX;
                clientY = event.touches[0].clientY;
            } else {
                clientX = event.clientX;
                clientY = event.clientY;
            }

            return {
                x: clientX - rect.left,
                y: clientY - rect.top
            };
        }

        function handleStart(event) {
            if (gameState !== 'playing' || hasLaunched) return;
            const pos = getEventPos(event);

            const dist = Math.sqrt(Math.pow(pos.x - bird.x, 2) + Math.pow(pos.y - bird.y, 2));
            if (dist < bird.radius) {
                isDragging = true;
                event.preventDefault();
            }
        }

        function handleMove(event) {
            if (gameState !== 'playing' || !isDragging || hasLaunched) return;
            const pos = getEventPos(event);

            const dx = pos.x - SLINGSHOT_X;
            const dy = pos.y - SLINGSHOT_Y;
            const distance = Math.min(Math.sqrt(dx * dx + dy * dy), MAX_PULL_DISTANCE);

            const angle = Math.atan2(dy, dx);

            bird.x = SLINGSHOT_X + Math.cos(angle) * distance;
            bird.y = SLINGSHOT_Y + Math.sin(angle) * distance;

            // Increased velocity multiplier from 0.35 to 0.5 for faster gameplay
            launchVelocityX = (SLINGSHOT_X - bird.x) * 0.5;
            launchVelocityY = (SLINGSHOT_Y - bird.y) * 0.5;
        }

        function handleEnd() {
            if (gameState !== 'playing' || isDragging && !hasLaunched) {
                hasLaunched = true;
                bird.vx = launchVelocityX;
                bird.vy = launchVelocityY;
                isDragging = false;
                bird.onGround = false;
            }
        }

        // Main menu start button
        startButton.addEventListener('click', initGame);
        // Reset button in game
        document.getElementById('resetButton').addEventListener('click', initGame);

        // Handle orientation changes
        function handleOrientation() {
            const orientationWarning = document.getElementById('orientationWarning');
            const isMobile = /Android|webOS|iPhone|iPad|iPod|BlackBerry|IEMobile|Opera Mini/i.test(navigator.userAgent);
            const isPortrait = window.innerHeight > window.innerWidth;
            
            if (isMobile && isPortrait) {
                orientationWarning.style.display = 'flex';
                startScreen.style.display = 'none';
                gameContainer.style.display = 'none';
            } else {
                orientationWarning.style.display = 'none';
                if (gameState === 'menu') {
                    startScreen.style.display = 'flex';
                    gameContainer.style.display = 'none';
                } else {
                    startScreen.style.display = 'none';
                    gameContainer.style.display = 'flex';
                }
            }
        }

        // Listen for orientation changes
        window.addEventListener('orientationchange', handleOrientation);
        window.addEventListener('resize', handleOrientation);

        // Initial setup on window load
        window.onload = function() {
            handleOrientation();
            if (!/Android|webOS|iPhone|iPad|iPod|BlackBerry|IEMobile|Opera Mini/i.test(navigator.userAgent)) {
                // Desktop - show start screen
                startScreen.style.display = 'flex';
                gameContainer.style.display = 'none';
            }
        };
    </script>
</body>
</html>